<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy Text Buttons</title>
    <style>
        button {
            margin: 5px;
        }

        body {
            background-color: #f0f0f0;
            /* Light gray background */
            font-family: Arial, sans-serif;
            text-align: center;
        }

        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: #ddd;
            /* Light gray button background */
            border: 1px solid #aaa;
            /* Dark gray border */
            cursor: pointer;
        }

        button:hover {
            background-color: #ccc;
            /* Slightly darker background on hover */
        }
    </style>
</head>

<body>

    <button onclick="copyText(text1)">Linear Neural Network Model</button>
    <button onclick=" copyText(text2)">McCulloch pitts</button>
    <button onclick="copyText(text3)">iD3 Decisionn Tree</button>
    <button onclick="copyText(text4)">SVM</button>
    <button onclick="copyText(text5)">K-Nearest</button>
    <button onclick="copyText(text6)">Naive Bayes</button>
    <button onclick="copyText(text7)">K-Means</button>
    
    
    <p id="copiedMsg"></p>
    <script>
        var text1 = `#Pract 1 :Linear Neural Network Model

        A = float(input("Enter number"))
        x=float(input("Enter value of x:"))
        w=float(input("Enter value of w:"))
        b=float(input("Enter value of b:"))
        net = int(w*x+b)
        if(net<0):
            out=0
        elif((net>=0)&(net<=1)):
            out=net
        else:
            out=1
        print("net=",net)
        print("output=",out)
        
        #number of elements as input
        n = int(input("Enter number of elements:"))
        
        print("Enter the inputs:")
        inputs= [] #creating an empty list for inputs
        #iternating till the range
        for i in range(0,n):
            ele = float(input())
            inputs.append(ele) #adding the element
        print(inputs)
        
        print("Enter the weights:")
        weights= [] #creating an empty list for inputs
        #iternating till the range
        for i in range(0,n):
            ele = float(input())
            weights.append(ele) #adding the element
        print(weights)
        
        print("The net input can be calculated as Yin = x1w1 + x2w2 + x3w3")
        # In[5]
        Yin= []
        for i in range(0,n):
            Yin.append(inputs[i]*weights[i])
        print(round(sum(Yin),3))
        print("Name")
    `;
        var text2 = `#Practical 2 - McCulloch pitts

        import numpy
        #We Will Take the no of values/inputs
        num_ip = int(input("Enter the number of inputs:"))
        # set the weights with value 1
        w1= 1
        w2= 1
        print("For the",num_ip,"inputs calculate the net input using yin= x1w1 + x2w2")
        x1= []
        x2= []
        print("-------------------------")
        print("Name")
        print("-------------------------")
        
        for j in range(0,num_ip):
            e1e1 = int(input("x1 = "))
            e1e2 = int(input("x2 = "))
            x1.append(e1e1)
            x2.append(e1e2)
        print("x1 = ",x1)
        print("x2 = ",x2)
        
        n = x1 * w1
        m = x2 * w2
        Yin = []
        for i in range(0,num_ip):
            Yin.append(n[i] + m[i])
        print("Yin =", Yin)
        
        #Assume one weight as excitatory and the other as inhibitory, i.e,
        Yin = []
        for i in range(0,num_ip):
            Yin.append(n[i] - m[i])
        print("After assuming one weight as excitatory and the other as inhibitory Yin=", Yin)
        
        #from the calculated net inputs, now it is possible yo fire the neuron for input(1,-1)
        # only by fixing a threshold of 1, i.e., 0 > 1 for Y unit
        # Thus, w1 = 1, w2= -1, 0>=15
        Y=[]
        for i in range(0,num_ip):
            if(Yin[i]>=1):
                ele=1
                Y.append(ele)
            if(Yin[i]<1):
                ele=0
                Y.append(ele)
        print("Y=",Y)
`;

        var text3 = `
        #Pract 3 - iD3 Decisionn Tree

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn import tree

print('-------------------------')
print('Name')
print('-------------------------')
dataTable = pd.read_csv("/content/play_tennis.csv")
dataTable

dataTable.shape

dataTable.describe()

dataTable.dtypes

dataTable.head(5)

dataTable.tail(5)

dataTable.columns

from sklearn.preprocessing import LabelEncoder
Le = LabelEncoder()
dataTable['day'] = Le.fit_transform(dataTable ['day'])
dataTable['outlook'] = Le.fit_transform(dataTable ['outlook'])
dataTable['temp'] = Le.fit_transform (dataTable ['temp'])
dataTable['humidity'] = Le.fit_transform(dataTable['humidity'])
dataTable['wind'] = Le.fit_transform (dataTable['wind'])
dataTable['play'] = Le.fit_transform (dataTable['play'])
dataTable

print("KFMSCIT014 Shipra Jana")
y = dataTable['play']
x = dataTable.drop(['play'], axis=1)
x.dtypes

from sklearn import tree
print("KFMSCIT014 Shipra Jana")
clf = tree.DecisionTreeClassifier(criterion = 'entropy')
clf = clf.fit(x,y)
tree.plot_tree(clf)
`;

        var text4 = `
        #Pract 4 - SVM

import pandas as pd
import numpy as  np
import seaborn as sns
from sklearn.model_selection import train_test_split,cross_val_score,cross_val_predict
from sklearn import svm
from sklearn.svm import SVC,LinearSVC
from sklearn.metrics import confusion_matrix,accuracy_score,classification_report

pd.set_option('display.max_rows',1000)
pd.set_option('display.max_columns',1000)
pd.set_option('display.width',1000)

data = pd.read_csv('/content/diabetes.csv')

data.head(5)

data.tail(5)

data.shape

data.describe()

x = data.drop('Outcome',axis=1)
y = data['Outcome']

xtrain = x.iloc[:600]
xtest = x.iloc[600:]
ytrain = y[:600]
ytest = y[600:]
print('-------------------------')
print('Name')
print('-------------------------')
print("xtrain Shape: ",xtrain.shape)
print("xtest Shape: ",xtest.shape)
print("ytrain Shape: ",ytrain.shape)
print("ytest Shape: ",ytest.shape)

svcobj = SVC(kernel="linear").fit(xtrain,ytrain)

svcobj

svcobj.C

ypred = svcobj.predict(xtest)

cm = confusion_matrix(ytest,ypred)

print(cm)
print('-------------------------')
print('Name')
print('-------------------------')
`;

        var text5 = `
        #Pract 5 : K-Nearest

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_curve
from sklearn.metrics import classification_report

print('-------------------------')
print('Name')
print('-------------------------')
df = pd.read_csv("/content/diabetes.csv")
df.head()

x = df.drop('Outcome',axis=1).values
y = df['Outcome'].values

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.4,random_state = 42)

neighbors = np.arange(1,9)
train_accuracy = np.empty(len(neighbors))
test_accuracy = np.empty(len(neighbors))

for i,k in enumerate(neighbors):
  knn = KNeighborsClassifier(n_neighbors= k)
  knn.fit(x_train,y_train)
  train_accuracy[i] = knn.score(x_train,y_train)
  test_accuracy[i] =    knn.score(x_test,y_test)

plt.title('k-NN Varying number of neighbors')
plt.plot(neighbors,test_accuracy,label='Testing Accuracy')
plt.plot(neighbors,train_accuracy,label='Training Accuracy')
plt.legend()
plt.xlabel('Number of neighbors')
plt.ylabel('Accuracy')
plt.show()

knn= KNeighborsClassifier(n_neighbors=7)

knn.fit(x_train,y_train)
KNeighborsClassifier(n_neighbors=7)

knn.score(x_test,y_test)

y_pred = knn.predict(x_test)

confusion_matrix(y_test,y_pred)

print('-------------------------')
print('Name')
print('-------------------------')
print(classification_report(y_test,y_pred))

y_pred_proba = knn.predict_proba (x_test)[:,1]

fpr, tpr, thresholds = roc_curve (y_test, y_pred_proba)

print('-------------------------')
print('Name')
print('-------------------------')
plt.plot([0,1],[0,1], 'k--')
plt.plot(fpr, tpr, label='Knn')
plt.xlabel('fpr')
plt.ylabel('tpr')
plt.title('Knn(n_neighbors=7) ROC curve')
plt.show()

from sklearn.metrics import roc_auc_score
roc_auc_score
(y_test,y_pred_proba)

from sklearn.model_selection import GridSearchCV
param_grid = {'n_neighbors': np.arange(1,50)}

knn = KNeighborsClassifier()
knn_cv= GridSearchCV (knn, param_grid,cv=5)
knn_cv.fit(x,y)

print('-------------------------')
print('Name')
print('-------------------------')
knn_cv.best_params_

knn_cv.best_score_
        
  `;
  
        var text6 = `
        #Practical 6 - Naive Bayes

import pandas as pd
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score

from sklearn.naive_bayes import MultinomialNB ,CategoricalNB
from sklearn.metrics import classification_report,accuracy_score,confusion_matrix

#importing dataset
print("Name")
iris= pd.read_csv("/content/Iris.csv")
iris

#print top 5
print("Name")
iris.head(5)

#print last 5
print("Name")
iris.tail(5)

iris.shape

iris.describe

iris.info()

iris.columns

iris.dtypes

print("Name")
#selecting all values of 'SepalLengthCm','SepalWidthCm','PetalLengthCm','PetalWidthCm'
X = iris.iloc[:,[1,2,3,4]].values
#Selecting all values of species (Prediction output)
y = iris.iloc[:,[5]].values

print("Name")
x_train, x_test , y_train, y_test = train_test_split(X,y,test_size=0.2, random_state=40)
print("Split the dataset (X and Y) into training and testing sets successfully")

print("Name")
print("**********FOR GAUSSAIN NAIVE BAYES CLASSIFICATION*************")
GNBclf= GaussianNB()
GNBclf.fit(x_train,y_train)
y_pred = GNBclf.predict(x_test)
out = GNBclf.predict([[5.9,3.0,5.1,1.8]])
print("Predicted Species:",out)

print("Name")
print("Confusion Matrix\n",confusion_matrix(y_test,y_pred))

print("Name")
print("classification Matrix\n",classification_report(y_test,y_pred))

print("Name")
print("Accuracy\n",accuracy_score(y_test,y_pred))
`;

        var text7 = `
        #Practical 7 - K-Means

import pandas as pd
import warnings

#select only longitude,latitude and median house value
homeData = pd.read_csv("/content/housing.csv", usecols = ['longitude','latitude','median_house_value'])
homeData.head(5)

import seaborn as sns
#display the map with the help of longitude and latitude

sns.scatterplot(homeData,x = 'longitude',y = 'latitude',hue = 'median_house_value')

from sklearn.model_selection import train_test_split

Xtrain,Xtest,Ytrain,Ytest = train_test_split(homeData[['longitude','latitude']],homeData[['median_house_value']],test_size=0.33,random_state=0)
#Xtrain,Xtest,Ytrain,Ytest = train_test_split(homeData[['longitude','latitude','median_house_value']],test_size=0.33,random_state=42)

from sklearn import preprocessing
#normalise the data i.e avoiding outliers
XtrainNorm = preprocessing.normalize(Xtrain)
XtestNorm = preprocessing.normalize(Xtest)

from sklearn.cluster import KMeans

#making the clusters of three
kmeans = KMeans(n_clusters= 3 ,random_state = 0)
kmeans.fit(XtrainNorm)

sns.scatterplot(Xtrain,x = 'longitude',y = 'latitude',hue = kmeans.labels_)

sns.boxplot(x = kmeans.labels_,y = Ytrain['median_house_value'])

from sklearn.metrics import silhouette_score
silScore = silhouette_score(XtrainNorm,kmeans.labels_,metric = 'euclidean')

K = range(2,8)
fits = []
score = []

for k in K:
    #train the model for current value of k on training data
    model = KMeans(n_clusters = k, random_state = 0).fit(XtrainNorm)

    #append the model to fits
    fits.append(model)

    #append the silhouette score to scores
    score.append(silhouette_score(XtrainNorm, model.labels_, metric='euclidean'))

sns.scatterplot(data = Xtrain, x='longitude',y='latitude', hue = fits[2].labels_)

sns.scatterplot(data = Xtrain, x='longitude',y='latitude', hue = fits[5].labels_)

sns.lineplot(x=K,y=score)

`;


function copyText(text) {
    navigator.clipboard.writeText(text).then(function () {
        document.getElementById('copiedMsg').innerHTML = "Text Copied"
    }).catch(function (err) {
        console.error('Unable to copy text', err);
    });
}
</script>

</body>

</html>
